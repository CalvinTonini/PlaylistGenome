# PlaylistGenomeProject
### Bianca Trombetta, Calvin Tonini, Chris Ramirez

### Set-Up and Execution Instructions:
1. To enable crawling over public playlists, enter _pip install spotipy_ into 
   the terminal. The spotipy module allows you to interface with and
   authenticate against the Spotify API over the network.
   
2. To use the crawler, you will need to acquire authentication credentials 
   through the Spotify API. We have provided various sample data sets already
   generated by the crawler for you to use, in the data folder. The data 
   with the name "hour" is a hundred playlists based off a different seed
   than "ramchris" which has ten playlists.

   Before being able to use the crawler and generate a playlists.pyfile,
   environment authentication variables need to be set in the shell before
   running the crawler. Contact Spotify to register your application and obtain
   credentials.
   
   To run the crawler, enter _python crawler.py [username] [number]_ into the 
   terminal. Replace _[username]_ with the username you want to start crawling 
   from, and _[number]_ with the number of playlists you want to crawl over.

   The crawler will return a URL that a user will need to take into any browser
   to allow the crawler to access Spotify through their user credentials. After
   authenticating, copy and paste the return URL back into the script. The
   spotipy python package handles the cookies and tokenization.

3. To create a graph data structure from the raw data generated by crawler, 
   enter _python graphmaker.py [playlists.pyfile]_ into the terminal. Replace
   _[playlists.pyfile]_ with the name of playlist pyfile you want to use 
   (e.g. playlists\_ramchris.pyfile).

4. To run the Floyd-Warshall's algorithm on your newly generated graph data
   structure, enter _python fasterpathfinder.py [graph.pyfile]_ into the 
   terminal. Replace _[graph.pyfile]_ with the name of the graph pyfile you want
   to use (e.g. graph\_ramchris.pyfile). Running fasterpathfinder will generate
   a shortest distance matrix, a shortest path matrix, and a list of all the 
   songs in your graph. This information will be stored as dist.pyfile, 
   path.pyfile, and songlist.pyfile (respectively).
   
   fasterpathfinder.py is an optimized implementation of pathfinder.py. We
   included the code for pathfinder.py to show our understanding of
   Floyd-Warshall's, although we don't use it to generate matrices.
   
   **NOTE**: steps 1-4 _MUST_ be completed before executing any of the following 
   code! All of our algorithms assume completed graphs, and path and distance
   matricies.

5. To run Centrality Algorithms to find the most central song of your graph 
   data structure, enter _python centrality.py [dist.pyfile] [path.pyfile] 
   [songlist.pyfile] [int between 0 and 3]_ into the terminal. Replace 
   _[dist.pyfile]_, _[path.pyfile]_, and _[songlist.pyfile]_ with the names of 
   the pyfiles you want to use (e.g. dist\_ramchris.pyfile, 
   path\_ramchris.pyfile, songlist\_ramchris.pyfile). Replace 
   _[int between 0 and 3]_ with a single number (either 0, 1, 2, or 3). Each of 
   these numbers refers to a different implementation of centrality within 
   centrality.py, as follows:
   
   * 0 = Bavelas's Closeness Centrality
   * 1 = Harmonic Centrality
   * 2 = Dangalchev's Centrality
   * 3 = Betweenness Centrality

6. To generate a list of all of the songs on the shortest path between two
   songs, enter _python generatepath.py [path.pyfile] [songlist.pyfile] 
   [song\_1] [song\_2]_ into the terminal. Replace _[path.pyfile]_ and
   _[songlist.pyfile]_ with the names of the pyfiles you want to use (e.g.
   path\_ramchris.pyfile and songlist\_ramchris.pyfile). Replace _[song\_1]_
   and _[song\_2]_ with the names of two songs in your graph (you can refer
   to the relevant songlist.pyfile if you want to look at what songs you have!). 
   The song names must be entered as _strings_ in the terminal.

7. To generate a list of the closest songs in relation to a given song, enter
   _python neighborfinder.py [songlist.pyfile] [dist.pyfile] [song] [number]_. 
   Replace _[songlist.pyfile]_ and _[dist.pyfile]_ with the names of the pyfiles
   you want to use (e.g. songlist\_ramchris.pyfile and dist\_ramchris.pyfile).
   Replace _[song]_ with the name of a song in your graph (you can refer to
   the relevant songlist.pyfile if you want to look at what songs you have!).
   The song name must be entered as a _string_ in the terminal. Replace
   _[number]_ with the number of songs you want to return in your generated
   list. This list will contain your requested number of songs (if possible), 
   ordered by closeness from the closest song to the farthest.

8. playlistneighborfinder.py uses Betweenness Centrality to find the most
   traversed song on the shortest path between all input songs and the rest of
   the graph. To generate a song based on a list of songs, enter _python 
   playlistneighborfinder.py [path.pyfile] [songlist.pyfile]_ in the terminal.
   Replace _[path.pyfile]_ and _[songlist.pyfile]_ with the names of the pyfiles
   you want to use (e.g. path\_ramchris.pyfile and songlist\_ramchris.pyfile).
   The terminal will then prompt you to enter song names one at a time (you 
   can refer to the relevant songlist.pyfile if you want to look at what songs
   you have!). We suggest entering in around 3-4 song names to start.

9. To find a trio of songs that are all connected that aren't on the same
   playlist together, enter _python triangles.py [graph.pyfile]_
   _[playlists.pyfile] [dist.pyfile] [songlist.pyfile] [song]_ in
   the terminal. Replace _[graph.pyfile]_ with the name of the pyfile you want 
   to use (e.g. graph\_ramchris.pyfile). Replace _[song]_ with the name of a 
   song in your graph (you can refer to the relevant songlist.pyfile if you want
   to look at what songs you have!). Also add in the relevant dist.pyfile
   songlist.pyfile! The song name must be entered as a _string_
   in the terminal. triangles.py returns the closest trio of songs (if 
   possible) containing the requested song. This is a neat way to generate 
   suggestions to create new playlists!

10. To create an atlas visualization of the graph data structure, you must first
   enter _pip install networkx_ and _pip install matplotlib.pyplot_ in the
   terminal. You may also have to install these programs on the OS level, 
   especially the matplotlib, which is a seperate binary. We have also
   provided an example visualization output for you to look at, in the report 
   folder.
   
   If you would like to generate your own visualization, enter _python
   networkx\_convert.py [graph.pyfile]_ in the terminal. Replace 
   _[graph.pyfile]_ with the name of the pyfile you want to use (e.g. 
   graph\_ramchris.pyfile). The visualization will open in a separate program,
   where you can save it as a .png, or zoom in to look at connections more
   closely. Voila!
   
   
